==== General notes ====

* If some object described as having length NN symbols (without terminational
* '\n' if present), but it contain least count of symbols, therefore it
* completed with spaces from the left.

* Parser must know length of each table cell.

* 'something' is one lexeme (token, word).

* NICK is lexeme, length is 10 symbols, not contain ':'.

* [ SOMETHING ] mean that SOMETHING is optional, can be presented,
* can be not (expanded with spaces).

* { SOMETHING }{n} mean that SOMETHING repeated n times.

* { SOMETHING }{n-m} mean that SOMETHING repeated from n to m times.

* NUMBER is unsigned 32-bit number, length: 10.

* HEADER(NN) and TEXT(NN) cannot contain '\n', TEXT(NN) cannot contain ':'.
* This contain maximum NN symbols (but can be least). NN is in range [10; 80].

* Note: TEXT implemented via 'add_str' function. We not make static or runtime
* checks for length or other restriction, simply make messages conforming them
* (and make checks for nick before accept it).

* MULTILINE_TEXT cannot contain MULTILINE_TEXT_END not in end. First line must
* contain maximum 78 symbols, follow lines must contain maximum 80 symbols
* (without '\n').

* Objects with name suffix MSG_ is messages. Server output is such messages
* stream.

==== Commands list ====

* help [command]
* nick [nick]
* clients
* players
* requests
* market
* build count
* make count
* buy count cost
* sell count cost
* turn
* join

==== Common message objects ====

SPACES -> { " " }{0-infty}
NUMBER -> { [0-9] }{1-10}
NUMBER_SHORT -> { [0-9] }{1-7}

#if 0
NUMBER_OR_SPACES       -> SPACES [ NUMBER ]
// Length: 10.
NUMBER_OR_SPACES_SHORT -> SPACES [ NUMBER_SHORT ]
// Length: 7.
#endif

NUMBER_EXPLICIT       -> SPACES NUMBER
// Length: 10.
NUMBER_EXPLICIT_SHORT -> SPACES NUMBER_SHORT
// Length: 7.

IS(str)  -> str | SPACES

POSITIVE -> SPACES [ '+' NUMBER_SHORT ]
NEGATIVE -> SPACES [ '-' NUMBER_SHORT ]
// Length: 8.

RISE    -> SPACES [ '+' '$' NUMBER ]
EXPENSE -> SPACES [ '-' '$' NUMBER ]
// Length: 12.

MONEY   -> SPACES (('$' NUMBER) | ('-' '$' NUMBER))
// Length: 12.

NUMBER_SMALL -> (' ' | [1-9]){2} [0-9]
// Length: 3.

PROCENT ->  NUMBER_SMALL '%'
// Length: 4.

MULTILINE_TEXT_END  -> "\n----\n"

MULTILINE_TEXT(str) -> str MULTILINE_TEXT_END

HEADER(str) -> str '\n'

LIST_END    -> "----\n"

NICKNAME(str) -> SPACES str
// Length: 10.

==== Prefixes ====

* All prefixes has length 2.

OK    -> '+' ' '
FAIL  -> '-' ' '

PREFIX_PROTO         -> 'p' ' '
PREFIX_DISCONNECTING -> 'e' ' '
PREFIX_ROUND_NEW     -> 'r' ' '
PREFIX_MONTH_OVER    -> 'm' ' '
PREFIX_ROUND_OVER    -> 'o' ' '
PREFIX_NICK_CHANGED  -> 'n' ' '
PREFIX_DISCONNECTING -> 'd' ' '
PREFIX_INFO          -> 'i' ' '

==== First message ====

PREFIX_PROTO TEXT(69) ':' ' ' NUMBER '\n'
// Number is protocol version.

==== Prompt ====

TIME -> '[' [0-9]{2} ':' [0-9]{2} ':' [0-9]{2} ']' | SPACES
// Length: 10.

MSG_PROMPT -> TIME " $ "
// Length: 13.

==== Common commands stuff ====

MSG_CMD_OK    -> OK   TEXT(78) '\n'
MSG_CMD_FAIL  -> FAIL TEXT(78) '\n'
MSG_CMD_WRONG -> FAIL TEXT(78) '\n'

==== Command responces (help, nick, clients) ====

// clients
+ Nickname  State
0000000000 000000

$ help
MSG_CMD_HELP_0 -> OK MULTILINE_TEXT

$ help CMD_NAME
MSG_CMD_HELP_1 -> OK MULTILINE_TEXT
MSG_CMD_FAIL
// Fail conditions: unknown command.

$ nick
MSG_CMD_NICK_0 -> OK TEXT(66) ':' ' ' NICK '\n'

$ nick NICK
MSG_CMD_OK
MSG_CMD_FAIL
// Fail conditions: already exists, contain forbidden symbols or too long.

$ clients
MSG_CMD_CLIENTS -> OK HEADER(78) { NICK ' ' CLIENT_STATE '\n' }{0-infty}
    LIST_END
// Columns: nick, state.

CLIENT_STATE -> "       " |
                " player" |
                "wishful"
// Length: 6.

==== Command responces (players) ====

// PLAYERS_T
+ Nickname        Money        Raw       Prod       Fact M.turn?
0000000000 0$0000000000 0000000000 0000000000 0000000000 0000

$ players
MSG_CMD_PLAYERS -> OK HEADER(78) { PLAYERS_T_ENTRY }{1-infty} LIST_END
MSG_CMD_FAIL
// Fail conditions: game is over.

PLAYERS_T_ENTRY -> NICK ' ' MONEY ' ' NUMBER_EXPLICIT ' ' NUMBER_EXPLICIT
    ' ' NUMBER_EXPLICIT ' ' IS("turn") '\n'
// Columns: nick, money, raw, prod, fact, is turned.
// Length: 61 (10+12+3*10+4+5).

==== Command responces (requests) ====

// REQ_T1
+    Raw     Raw cost     Prod    Prod cost  To make    Make cost
+0000000 -$0000000000 -0000000 +$0000000000 +0000000 -$0000000000

// REQ_T2
To build   Fact pay 1   Fact pay 2  Raw expense Prod expense Fact expense
+0000000 -$0000000000 -$0000000000 -$0000000000 -$0000000000 -$0000000000

$ requests
MSG_CMD_REQUESTS -> OK REQ_T1 REQ_T2
MSG_CMD_FAIL
// Fail conditions: game is over.

REQ_T1 -> POSITIVE ' ' EXPENSE ' ' NEGATIVE ' ' RISE
    ' ' POSITIVE ' ' EXPENSE '\n'
// Columns: raw, raw cost, prod, prod cost, make, make cost.
// Length: 65 (8*3+12*3+5).

REQ_T2 -> POSITIVE ' ' EXPENSE ' ' EXPENSE ' ' EXPENSE
    ' ' EXPENSE ' ' EXPENSE '\n'
// Columns: fact, pay 1, pay 2, raw exp, prod exp, fact exp.
// Length: 73 (8+12*5+5).

==== Command responces (market) ====

// MARKET_T
+    Month   Level        Raw     Raw cost       Prod    Prod cost
0000000000 0000000 0000000000 0$0000000000 0000000000 0$0000000000

// NEXT_LVL_T
Levels probability
000% 000% 000% 000% 000%

$ market
MSG_CMD_MARKET -> OK MARKET_T NEXT_LVL_T
MSG_CMD_FAIL
// Fail conditions: game is over.

MARKET_T -> HEADER(78) NUMBER_EXPLICIT ' ' NUMBER_EXPLICIT_SHORT
    ' ' NUMBER_EXPLICIT ' ' MONEY ' ' NUMBER_EXPLICIT ' ' MONEY '\n'
// Columns: month, level, raw, raw_cost, prod, prod_cost.
// Length: 66.

NEXT_LVL_T -> HEADER(80) '\n' PROCENT ' ' PROCENT ' ' PROCENT ' ' PROCENT
    ' ' PROCENT '\n'
// Procents: level 1, 2, 3, 4, 5.
// Length: 19 (3*5+4).

==== Command responces (build, make, buy, sell, turn, join) ====

$ build NUMBER        // count
$ make  NUMBER        // count
$ buy   NUMBER NUMBER // count and cost
$ sell  NUMBER NUMBER // count and cost
$ turn
MSG_CMD_OK
MSG_CMD_FAIL
// Fail conditions: game is over, not player, already closed month,
// market restriction or low player resources.

$ join
MSG_CMD_OK
MSG_CMD_FAIL
// Fail conditions: already make join request, currently in game (in round).

==== Asynchronous messages ====

// MONTH_OVER_T1
  Nickname      Raw     Raw cost     Prod    Prod cost
0000000000 +0000000 -$0000000000 -0000000 +$0000000000

// MONTH_OVER_T2
  Nickname  To make    Make cost    Build   Fact pay 1   Fact pay 2
0000000000 +0000000 -$0000000000 +0000000 -$0000000000 -$0000000000

// MONTH_OVER_T3
  Nickname  Raw expense Prod expense Fact expense        Money Resolu-n
0000000000 -$0000000000 -$0000000000 -$0000000000 0$0000000000 00000000

* We have seven async. messages: early disconecting, new round, month over,
* nick changing, round over, disconnecting and information for user.

* EARLY_DISCONNECTING message mean that server disconnect you before choose
* nickname. Other users not notified about this.

* ROUND_NEW can be arrived after apropos 'join' command.

* MONTH_OVER can be arrived after apropos 'turn' command (more exactly, after
* all players entered 'turn' command).

* After that you can arrive ROUND_OVER message.

* DISCONNECTING message sent to client, which will be disconnected now. Also,
* this message sent to all connected clients.

* NICK_CHANGED, DISCONNECTING and INFO messages can be sent before or after any
* messages.

* INFO message provide information, which useless for bot, but desined for
* human user.

EARLY_DISCONNECTING -> PREFIX_EARLY_DISCONNECTING TEXT(78) '\n'
ROUND_NEW     -> PREFIX_ROUND_NEW     TEXT(78) '\n' PLAYERS_LIST
MONTH_OVER    -> PREFIX_MONTH_OVER    TEXT(78) '\n'
    MONTH_OVER_T1 MONTH_OVER_T2 MONTH_OVER_T
ROUND_OVER    -> PREFIX_ROUND_OVER    TEXT(78) '\n' PLAYERS_LIST
NICK_CHANGED  -> PREFIX_NICK_CHANGED  NICK     " -> " NICK '\n'
DISCONNECTING -> PREFIX_DISCONNECTING NICK     ' '  TEXT(67) '\n'
INFO          -> PREFIX_INFO          TEXT(78) '\n'

PLAYERS_LIST -> { NICK '\n' }{1-infty} LIST_END
// Length: 10.

MONTH_OVER_T1 -> HEADER(80) '\n' { MONTH_OVER_T1_ENTRY }{1-infty} LIST_END
MONTH_OVER_T2 -> HEADER(80) '\n' { MONTH_OVER_T2_ENTRY }{1-infty} LIST_END
MONTH_OVER_T3 -> HEADER(80) '\n' { MONTH_OVER_T3_ENTRY }{1-infty} LIST_END

MONTH_OVER_T1_ENTRY -> NICK ' '  POSITIVE ' ' EXPENSE ' ' NEGATIVE
    ' ' RISE '\n'
// Columns: nick, raw, raw cost, prod, prod cost.
// Length: 54 (10+8*2+12*2+4).

MONTH_OVER_T2_ENTRY -> NICK ' ' POSITIVE ' ' EXPENSE ' ' POSITIVE
    ' ' EXPENSE ' ' EXPENSE '\n'
// Columns: nick, make, make cost, fact, pay 1, pay 2.
// Length: 67 (10+8*2+12*3+5).

MONTH_OVER_T3_ENTRY -> NICK ' ' EXPENSE ' ' EXPENSE ' ' EXPENSE
    ' ' MONEY ' ' IS("bankrupt") '\n'
// Columns: nick, raw, prod, fact, money, resolution.
// Length: 70 (10+12*4+8+4).

// vim: set ft=asciidoc:
