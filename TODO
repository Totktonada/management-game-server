* IPv6.

* Клиент с readline.

* Ники пользователей.

* UTF-8.

* Сокращения для команд. Любая последовательность символов, с которой может
* начинаться строго одна команда должна интерпретироваться как эта команда.

* Ловить ошибки write? (-1 или возвр. знач. != кол-ву байт, которое я хочу
* передать).

* Нормальне логи: подключение клиента, отключение (с причиной), получение
* команды от клиента такого-то.

* Параметры командной строки: демонизироваться ли, куда писать лог-файл.

* Приглашение к вводу.

* Вывод состояния сервера (ждём ли ещё игроков).

* Асинхронные уведомления о подключившихся игроках, смене ника, конце хода.
* Разбить события на типы, об отдельных типах событий уведомлять только игрока,
* у которого оно произошло, о некоторых событиях уведомлять всех игроков.

* cmd [--help | -h | -?]

* status [--common | -c] или status [--market | -m]

* prod -> make/mkprod?

* Строящиеся фабрики и прочие request'ы в status'е.

* Внести порядок в именование переменных и сообщения, передаваемые пользователю:
* request -> offer?
* step/month
* player/user/client
* nick/username

* Поддержка gettext, выстраивание отступов между ключом и значением
* автоматически.

* strlen (client->nick) — неоптимально. Посмотреть в сторону
* http://schacon.github.com/git/technical/api-strbuf.html

* Вариант механизма начала игры: один из игроков — администратор. Может выбрать
* некоторое количество клиентов (в т.ч. себя), которые будут играть в следующей
* игре. Остальные наблюдают.
* ---
* Либо можно вынести администраторскую консоль на отдельный сокет (можно даже на
* отдельный порт). Но первый вариант интереснее.
* ---
* Пока администратора нет (сразу после запуска сервера), стать администратором
* можно по паролю, который задаётся как-либо на стороне сервера (напр. хешем в
* конфиге). Ещё один вариант: по желанию текущего администратора, снимающего с
* себя полномочия. Либо по жребию (или по длительности нахождения на вервере,
* или по количеству выигрышей, или другой алгоритм выбора «самого достойного».)
* когда текущий администратор ушёл, не назначив другого.
* ---
* Когда игра заканчивается, снова начинается этап отбора игроков
* администратором. Несколько администраторов, думаю, не нужно.
* ---
* Вариант: администратор может выбирать только из тех игроков, которые сами
* заявились на следующую игру. На следующую игру могут заявляться любые игроки,
* если в данный момент игра не идёт, а если идёт, то только те, что не
* участвуют в текущей. Между играми надо бы небольшой тайм-аут, чтобы те
* игроки, которые играли сейчас могли успеть заявиться. Игроки, которые не
* заявились или не были отобраны могут наблюдать.
* ---
* Нужен ли администратор? Можно обойтись тайм-аутом между раундами. Тайм-аут
* можно заменить системой тайм-аутов, которые зависят от того, когда
* подключился последний игрок. Если кто-то просит задержаться, то можно и это
* сделать.
* ---
* Появляются категории рассылки сообщений: указанному клиенту, игрокам текущего
* раунда, всем.
* ---
* Можно собирать статистику по раундам, хех.
* ---
* С другой стороны, сложный механизм привелегий не нужен. Игру можно начать по
* команде первого подключившегося игрока. Вопрос: как быть с наблюдателями?

* Склеивать сообщения в буфер и отправлять одним write. Десятичный логарифм
* поможет в определении размера буфера для числа. Попробуем обрисовать задачи
* для накопительного буфера для сообщения: Склеивать константные строки,
* неконстантные строки, числа. Для первых двух имеем длину, для чисел —
* вычисляемо. Не пересчитывать длину после склеивания. Отправлять.
* Методы:
** Инициализация.
** Добавить строку (константную или неконстантную). Параметры: указатель, длина.
** Добавить число.
** Отправить и очистить.
* Этот макрос поможет при передаче параметров:
* #define write_str(fd, str) write(fd, str, sizeof(str) - 1)
* Where: http://code.turnkeylinux.org/busybox/networking/telnet.c
* В моём случае что-то вроде:
* #define ADD_STR(buf, str) buf_add_str (buf, str, sizeof (str) - 1)
